"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.goodbyeImage = exports.welcomeImage = exports.drawCard = exports.themes = exports.Gradient = void 0;
const canvas_1 = require("canvas");
const path_1 = require("path");
const fs_1 = require("fs");
const production = true;
canvas_1.CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (w < 2 * r)
        r = w / 2;
    if (h < 2 * r)
        r = h / 2;
    this.beginPath();
    this.moveTo(x + r, y);
    this.arcTo(x + w, y, x + w, y + h, r);
    this.arcTo(x + w, y + h, x, y + h, r);
    this.arcTo(x, y + h, x, y, r);
    this.arcTo(x, y, x + w, y, r);
    this.closePath();
    return this;
};
canvas_1.CanvasRenderingContext2D.prototype.changeFont = function (font) {
    var fontArgs = this.font.split(' ');
    this.font = fontArgs[0] + ' ' + font; /// using the first part
    return this;
};
canvas_1.CanvasRenderingContext2D.prototype.changeFontSize = function (size) {
    var fontArgs = this.font.split(' ');
    this.font = size + ' ' + fontArgs.slice(1).join(' '); /// using the last part
    return this;
};
canvas_1.CanvasRenderingContext2D.prototype.blur = function (strength = 1) {
    this.globalAlpha = 0.5; // Higher alpha made it more smooth
    // Add blur layers by strength to x and y
    // 2 made it a bit faster without noticeable quality loss
    for (var y = -strength; y <= strength; y += 2) {
        for (var x = -strength; x <= strength; x += 2) {
            // Apply layers
            this.drawImage(this.canvas, x, y);
            // Add an extra layer, prevents it from rendering lines
            // on top of the images (does makes it slower though)
            if (x >= 0 && y >= 0) {
                this.drawImage(this.canvas, -(x - 1), -(y - 1));
            }
        }
    }
    this.globalAlpha = 1.0;
    return this;
};
class Gradient {
    constructor(type = 'linear', ...colors) {
        this.type = type;
        this.colors = colors !== null && colors !== void 0 ? colors : [];
    }
    addColorStop(offset, color) {
        this.colors.push({ offset, color });
    }
    toString(ctx) {
        var grad = this.type === 'linear' ?
            ctx.createLinearGradient(0, 0, ctx.w, ctx.h)
            : ctx.createRadialGradient(ctx.w / 2, ctx.h / 2, ctx.w / 2, ctx.w / 2, ctx.h / 2, ctx.w / 2);
        for (const v of this.colors)
            grad.addColorStop(v.offset, v.color);
        return grad;
    }
}
exports.Gradient = Gradient;
const root = path_1.join(__dirname, '..', 'images');
exports.themes = {
    'dark': { color: '#ffffff', image: path_1.join(root, 'dark.png') },
    'sakura': { color: '#7d0b2b', image: path_1.join(root, 'sakura.png') },
    'blue': { color: '#040f57', image: path_1.join(root, 'blue.png') },
    'bamboo': { color: '#137a0d', image: path_1.join(root, 'bamboo.png') },
    'desert': { color: '#000000', image: path_1.join(root, 'desert.png'), font: 'Segoe Print' },
    'code': { color: '#ffffff', image: path_1.join(root, 'code.png'), font: 'Source Sans Pro' },
};
function getFontSize(str) {
    if (str.length < 18)
        return 30;
    return (600 * Math.pow(str.length, -1.05)).toFixed(0);
}
var count = 0;
function snap(c) {
    if (!production)
        fs_1.writeFileSync(`./snapshots/${count}.png`, c.toBuffer('image/png'));
    count++;
}
async function drawCard(options) {
    var _a, _b, _c, _d;
    const w = 700, h = 250;
    const canvas = canvas_1.createCanvas(w, h);
    const ctx = canvas.getContext('2d');
    ctx.w = ctx.width = w;
    ctx.h = ctx.height = h;
    //@ts-ignore
    var theme = (_a = options.theme) !== null && _a !== void 0 ? _a : 'sakura';
    var background;
    //Parsing the Theme
    if (typeof theme === 'string') {
        //Builtin Theme
        theme = exports.themes[theme];
        if (!theme)
            throw new Error('Invalid theme, use: ' + Object.keys(exports.themes).join(' | '));
        background = await canvas_1.loadImage(theme.image);
    }
    else {
        //Loading the Background
        try {
            background = await canvas_1.loadImage(theme.image);
        }
        catch (e) {
            throw new Error('Invalid Path or Buffer provided.');
        }
    }
    ctx.theme = theme;
    const b = 10; //Border
    //Background
    snap(canvas);
    if (options.rounded)
        ctx.roundRect(0, 0, w, h, h / 15);
    else
        ctx.rect(0, 0, w, h);
    ctx.clip();
    if (options.border) {
        ctx.drawImage(background, 0, 0, w, h);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
        ctx.blur(3);
    }
    snap(canvas);
    //Rounded Edges
    if (options.border) {
        if (options.rounded)
            ctx.roundRect(b, b, w - 2 * b, h - 2 * b, h / 15);
        else
            ctx.rect(b, b, w - (2 * b), h - (2 * b));
        ctx.clip();
    }
    else {
        if (options.rounded)
            ctx.roundRect(0, 0, w, h, h / 15).clip();
        else
            ctx.rect(0, 0, w, h);
    }
    var temp = background;
    if (options.blur) {
        console.log('Q');
        var blur = canvas_1.createCanvas(w, h), blur_ctx = blur.getContext('2d');
        blur_ctx.drawImage(background, 0, 0, w, h);
        if (typeof options.blur === 'boolean')
            blur_ctx.blur(3);
        else
            blur_ctx.blur(options.blur);
        temp = blur;
    }
    if (options.border)
        ctx.drawImage(temp, b, b, w - b * 2, h - b * 2);
    else
        ctx.drawImage(temp, 0, 0, w, h);
    snap(canvas);
    //Setting Styles
    ctx.fillStyle = theme.color.toString(ctx);
    ctx.strokeStyle = theme.color.toString(ctx);
    ctx.font = '30px ' + (theme.font ? theme.font : 'sans-serif');
    //Drawing
    //Title
    ctx.changeFontSize('30px')
        .fillText((_b = options.title) !== null && _b !== void 0 ? _b : '', ctx.width / 2.7, ctx.height / 3.5);
    //Text
    ctx.changeFontSize('40px')
        .fillText((_c = options.text) !== null && _c !== void 0 ? _c : '', ctx.width / 2.7, ctx.height / 1.8, (ctx.w * 3) / 5);
    //Subtitle
    ctx.changeFontSize('25px')
        .fillText((_d = options.subtitle) !== null && _d !== void 0 ? _d : '', ctx.width / 2.7, ctx.height / 1.3);
    //Avatar Image
    const radius = h / 2.5;
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(h / 2, h / 2, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();
    if (options.avatar) {
        if (options.avatar instanceof canvas_1.Canvas || options.avatar instanceof canvas_1.Image)
            ctx.drawImage(options.avatar, radius / 4, radius / 4, radius * 2, radius * 2);
        else if (typeof options.avatar === 'string' || options.avatar instanceof Buffer)
            ctx.drawImage(await canvas_1.loadImage(options.avatar), radius / 4, radius / 4, radius * 2, radius * 2);
        else
            throw new Error('Invalid Avatar Argument');
    }
    if (options.custom)
        options.custom(ctx);
    snap(canvas);
    return canvas.toBuffer('image/png');
}
exports.drawCard = drawCard;
async function welcomeImage(member, opts = {}) {
    var _a, _b, _c, _d, _e;
    opts.title = (_a = opts.title) !== null && _a !== void 0 ? _a : `Welcome to pi-ware,`;
    opts.text = (_b = opts.text) !== null && _b !== void 0 ? _b : `${member.user.tag}!`;
    opts.subtitle = (_c = opts.subtitle) !== null && _c !== void 0 ? _c : `MemberCount: ${member.guild.memberCount}`;
    opts.theme = (_d = opts.theme) !== null && _d !== void 0 ? _d : 'sakura';
    opts.avatar = (_e = opts.avatar) !== null && _e !== void 0 ? _e : await canvas_1.loadImage(member.user.displayAvatarURL({ format: 'png' }));
    const buff = await drawCard(opts);
    return buff;
}
exports.welcomeImage = welcomeImage;
async function goodbyeImage(member, opts = {}) {
    var _a, _b, _c, _d;
    opts.title = (_a = opts.title) !== null && _a !== void 0 ? _a : `Goodbye,`;
    opts.text = (_b = opts.text) !== null && _b !== void 0 ? _b : `${member.user.tag}!`;
    opts.theme = (_c = opts.theme) !== null && _c !== void 0 ? _c : 'sakura';
    opts.avatar = (_d = opts.avatar) !== null && _d !== void 0 ? _d : await canvas_1.loadImage(member.user.displayAvatarURL({ format: 'png' }));
    const buff = await drawCard(opts);
    return buff;
}
exports.goodbyeImage = goodbyeImage;
//# sourceMappingURL=index.js.map
